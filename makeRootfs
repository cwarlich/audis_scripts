#!/bin/bash
source `dirname $0`/audisLib
AUDIS_OPTIONS="c o j:"

usage() {
    echo "Usage: $0 [-h] [-c] [-o] [-j jobs] [toolchain board]"
    echo "Options: -c:     Delete all generated files."
    echo "         -o:     Use old style toolchains."
    echo "         -j jobs Do this many jobs in parallel."
}

audisBoard "$@"
if [ "$j" == "false" ]; then j=40; fi

if $AUDIS_INTERACTIVE; then
    read -p"Any additional parameter for the rootfs build: " AUDIS_PARAMETER3 1>&2
fi

rootfsDir=/storage/hd0b/target/$USER/$AUDIS_ARCH/$AUDIS_BOARD
kernel=/tftpboot/$USER/$AUDIS_ARCH/$AUDIS_BOARD

if $c; then setx rm -rf $rootfsdir $kernel; exit 0; fi

# Setup pretty output & logging.
tail -f $SCREEN --pid $$ | sed -e 's/^++* \(.*\)$/\1/' 2>/dev/null&
mkdir -p $AUDIS_GENERATED/modules/$AUDIS_ARCH/$AUDIS_BOARD
log=$AUDIS_GENERATED/modules/$AUDIS_ARCH/$AUDIS_BOARD/build.log
rm -f $log
exec 4>&1
trap "status=$? && sleep 1 && echo A logfile has been written to $log >&4; exit $status" EXIT
# Let's begin with rootfs setup.
swap banner "SETUP NEEDED TO BOOT" >>$log 2>&1
# Ensure that our destination directories are there.
swap setx mkdir -p $rootfsDir `dirname $kernel` >>$log 2>&1
# We need to set world writable permissions because booting
# the system will make everything to be owned by root.
swap setx sudo chmod -R 777 $rootfsDir >>$log 2>&1
# Let's start with a clean state
swap setx rm -rf $rootfsDir/* $kernel >>$log 2>&1
# Creating the directories that need initial content.
swap setx mkdir $rootfsDir/etc $rootfsDir/sbin $rootfsDir/dev $rootfsDir/audislib >>$log 2>&1
# The inittab creates the rest as needed during system boot time.
cat <<! >$rootfsDir/etc/inittab
# This inittab bootstraps a fully operational busybox-based
# root filesystem from just 3 files and a (symbolic) link.
# - an inittab (this file :-)) stored in /etc doing both the
#   bootstrapping magic (sysinit entries) _and_ the ordinary
#   system startup
# - the busybox executable itself, initially stored directly
#   in the toplevel directory of the rootfs
# - a link called init and linked to busybox, being needed
#   because the boot loader cannot properly call the initial
#   executable with a parameter, like e.g. /busybox init
# - The third file is the console device file needed due to a
#   bug?!; see below.

# We need to create a directory for the system's executables
# if they do not yet exist.
::sysinit:busybox mkdir -p /bin
# All the files being created during the bootstrap must only
# live in tmpfs filesystems to ensure that they are properly
# cleaned up on reboot. Furthermore, any additional executables
# that may need persistent storage would belong into either
# /usr/bin or /usr/sbin anyway.
::sysinit:busybox mount -t tmpfs binfs /bin
# We need the /proc filesystem so that busybox can be found
# through the /proc/self/exe created below. Interestingly, we
# need to do this _before_ installing the links: If we do it
# afterwards, dropbear logs us out immediately after successful
# authentication!
::sysinit:busybox mkdir -p /proc
::sysinit:busybox mount -t proc proc /proc
# Now we are ready to create the applet links to busybox.
# We put exerything under bin, which is quite appropriate for
# a system that is typically used by the root user only.
# Furthermore, this works arround a bug in the current busybox,
# causing /usr/bin and /usr/sbin to be populated even when
# busybox is configured with the CONFIG_INSTALL_NO_USR option.
::sysinit:busybox --install -s /bin
# We may now use the applets provided by busybox directly.
# The next step is to prepare creation of device nodes.
::sysinit:mkdir -p /dev
::sysinit:mount -t tmpfs devfs /dev
::sysinit:mkdir -p /dev/shm /dev/pts
# We need the /sys filesystem for mdev to work properly.
::sysinit:mkdir -p /sys
::sysinit:mount -t sysfs sys /sys
# Note that any modules should be loaded before that step to
# ensure that their device nodes are created properly.
::sysinit:mdev -s

# The system would now be ready to start a shell, but there
# is still some more work for a properly configured Linux
# system.
# We may want a temp directory.
::wait:mkdir -p /tmp
::wait:mount -t tmpfs tmpfs /tmp
# Start an initial console. Note that this _requires_
# /dev/console to exist _before_ the kernel passes control
# to init, which looks like a kernel bug imho.
::respawn:-sh

# Stuff to do before rebooting
::ctrlaltdel:reboot
::shutdown:umount -a -r

# Make file permissions as open as possible.
::wait:find / -xdev -type f -type d -exec chown 0:0 {} \;
::wait:find / -xdev -type f -type d -exec chmod +r {} \;
::wait:find / -xdev -type f -type d -exec chmod +w {} \;

# Dropbear (and probably others) like it this way.
::wait:chmod 755 /
::wait:mount -t devpts devpts /dev/pts
::wait:mkdir -p /var/log

# Continue with system startup.
::wait:sh -c "if [ -e /etc/rc.local ]; then sh /etc/rc.local; fi"
!
# We copy the busybox ...
swap setx cp -a $AUDIS_GENERATED/busybox/$AUDIS_TOOLCHAIN/busybox $rootfsDir/sbin >>$log 2>&1
# ... and provide init ...
cd $rootfsDir/sbin >>$log 2>&1
swap setx ln -s busybox init >>$log 2>&1
# ... and the damned console device.
swap setx sudo cp -a /dev/console $rootfsDir/dev >>$log 2>&1

# We copy the AuDis GLIBC.
swap banner "COPYING AUDIS GLIBC AND LIBAUDIS" >>$log 2>&1
# Anything from this point on is optional as it is not required to boot the system.
swap setx cp -a $AUDIS_GENERATED/nsr/toolchain/$AUDIS_TARGET/$AUDIS_TARGET/lib/*.so* $rootfsDir/audislib >>$log 2>&1
# System startup continues with this script.
cat <<! >$rootfsDir/etc/rc.local
#!/bin/sh
# This is onlx needed due to a bug in our toolchain and will be fixed soon.
mkdir -p /lib
ln -s /audislib/ld-linux.so.2 /lib
# We need a user database for any type of logins.
if ! [ -e /etc/passwd ]; then
    touch /etc/passwd /etc/group /etc/shadow
    adduser -u0 -D -h/root root
    # Set audis as password.
    sed -i 's/^\(root:\)[^:]*\(:.*\)$/\1\$1\$OsaeziAT\$B0YvsH1ML6QikSz3t4lBJ1\2/' /etc/shadow
    rm /etc/passwd- /etc/group- /etc/shadow-
fi
if [ -x /sbin/dropbear ]; then
    mkdir -p /etc/dropbear /var/log;
    touch /var/log/lastlog
    for i in rsa dss; do
        file=/etc/dropbear/dropbear_\${i}_host_key;
        if ! [ -e \$file ]; then
            dropbearkey -t \$i -f \$file >/dev/null;
        fi;
    done;
    # Note that dropbear cannot completely be statically
    # linked with glibc, as libnss* is only available as
    # shared library.
    dropbear;
fi
!

swap banner "INSTALLATION OF KERNEL AND MODULES" >>$log 2>&1
# Now we take care of the board specific
# part, i.e. the kernel and its modules.
swap setx cp -f $AUDIS_GENERATED/kernel/$AUDIS_ARCH/$AUDIS_BOARD/arch/$AUDIS_ARCH/boot/$AUDIS_KERNEL $kernel >>$log 2>&1
swap setx make -C $AUDIS_GENERATED/kernel/$AUDIS_ARCH/$AUDIS_BOARD INSTALL_MOD_PATH=$rootfsDir modules_install >>$log 2>&1
# Add additional module directories as desired.
MODULEDIRS=test_driver
for i in $MODULEDIRS; do
    swap setx mkdir -p $AUDIS_GENERATED/modules/$AUDIS_ARCH/$AUDIS_BOARD/$i >>$log 2>&1
    swap setx cp -f $AUDIS_SOURCE_PATH/pkgs/linux/drivers/aud/$i/* $AUDIS_GENERATED/modules/$AUDIS_ARCH/$AUDIS_BOARD/$i >>$log 2>&1
    swap setx make -j$j -C $AUDIS_GENERATED/kernel/$AUDIS_ARCH/$AUDIS_BOARD M=$AUDIS_GENERATED/modules/$AUDIS_ARCH/$AUDIS_BOARD/$i ARCH=$AUDIS_ARCH CROSS_COMPILE=$AUDIS_TOOL_PREFIX $AUDIS_PARAMETER3 >>$log 2>&1
    swap setx make -C $AUDIS_GENERATED/kernel/$AUDIS_ARCH/$AUDIS_BOARD M=$AUDIS_GENERATED/modules/$AUDIS_ARCH/$AUDIS_BOARD/$i ARCH=$AUDIS_ARCH CROSS_COMPILE=$AUDIS_TOOL_PREFIX INSTALL_MOD_PATH=$rootfsDir modules_install >>$log 2>&1
done
# We copy the gdb and dropbear server.
swap banner "COPYING DROPBEAR AND GDB SERVER" >>$log 2>&1
swap setx cp -a $AUDIS_GENERATED/nsr/toolchain/$AUDIS_TARGET/bin/$AUDIS_TARGET-gdbserver $rootfsDir/sbin/gdbserver >>$log 2>&1
swap setx cp -a $AUDIS_GENERATED/dropbear/$AUDIS_TOOLCHAIN/dropbear $rootfsDir/sbin >>$log 2>&1
swap setx cp -a $AUDIS_GENERATED/dropbear/$AUDIS_TOOLCHAIN/dropbearkey $rootfsDir/sbin >>$log 2>&1
# Creation and copy of test suite.
swap banner "CREATING AND INSTALLING TEST SUITE" >>$log 2>&1
swap setx make -C $AUDIS_SOURCE_PATH/ownsrc/aud_other/audis_testsuite -f Makefile Platforms=$AUDIS_TARGET >>$log 2>&1
swap setx make -C $AUDIS_SOURCE_PATH/ownsrc/aud_other/audis_testsuite -f Makefile Platforms=$AUDIS_TARGET install_rootfs >>$log 2>&1
#swap setx cp -f $AUDIS_GENERATED/testsuite/$AUDIS_TARGET/testsuite $rootfsDir/sbin >>$log 2>&1
# Done.
swap banner "FINISHED SUCCESSFULLY" >>$log 2>&1

# Dirty hack to wait for tail to print all its messages.
sleep 1
rm -f $SCREEN
